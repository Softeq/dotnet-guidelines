# Framework
## Use C# type aliases instead of the types from the System namespace (SDCS-1601) [1]
For instance, use `object` instead of `Object`, `string` instead of `String`, and `int` instead of `Int32`. These aliases have been introduced to make the primitive types first class citizens of the C# language, so use them accordingly.

**Exception:** When referring to static members of those types, it is custom to use the full CLS name, e.g. `Int32.Parse()` instead of `int.Parse()`.

## Properly name properties, variables or fields referring to localized resources (SDCS-1602) [3]
The guidelines in this topic apply to localizable resources such as error messages and menu text.

Provide descriptive identifiers rather than short ones. Keep them concise where possible, but don't sacrifice readability.

## Don't hard-code strings that change based on the deployment (SDCS-1603) [3]
Examples include connection strings, server addresses, etc. Use Resources, the ConnectionStrings property of the ConfigurationManager class, or the Settings class generated by Visual Studio. Maintain the actual values into the app.config or web.config (and most definitely not in a custom configuration store).

## Build with the highest warning level (SDCS-1604) [1]
Configure the development environment to use Warning Level 4 for the C# compiler, and enable the option Treat warnings as errors . This allows the compiler to enforce the highest possible code quality.

## Properly fill the attributes of the AssemblyInfo.cs file (SDCS-1605) [1]
Ensure that the attributes for the company name, description, copyright statement, version, etc. are filled. One way to ensure that version and other fields that are common to all assemblies have the same values, is to move the corresponding attributes out of the `AssemblyInfo.cs` into a `SolutionInfo.cs` file that is shared by all projects within a solution.

```csharp
[assembly: AssemblyProduct("Product name")]
[assembly: AssemblyDescription("Short product description")]
[assembly: AssemblyCompany("Company Name")]
[assembly: AssemblyCopyright("Copyright (c) 2020 Company Name")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
```

**Exception:** prototypes and demo apps can skip that rule.

## Avoid LINQ for simple expressions (SDCS-1606) [2]
```csharp
// GOOD
var query = items.Where(i => i.Length > 0);
```
```csharp
// BAD
var query = from item in items where item.Length > 0;
```

## Use Lambda expressions instead of delegates (SDCS-1607) [1]
Lambda expressions provide a much more elegant alternative for anonymous delegates.

```csharp
// GOOD
Customer c = Array.Find(customers, c => c.Name == "Tom");
// or
var customer = customers.Where(c => c.Name == "Tom");
```
```csharp
// BAD
Customer c = Array.Find(customers, delegate(Customer c)
{
   return c.Name == "Tom";
});
```

## Only use the dynamic keyword when talking to a dynamic object (SDCS-1608) [1]
The dynamic keyword has been introduced for working with dynamic languages. Using it introduces a serious performance bottleneck because the compiler has to generate some complex Reflection code.
Use it only for calling methods or members of a dynamically created instance class (using the `Activator`) as an alternative to `Type.GetProperty()` and `Type.GetMethod()`, or for working with COM Interop types.

## Favor async/await over the Task (SDCS-1609) [1]
Using the new C# 5.0 keywords results in code that can still be read sequentially and also improves maintainability a lot, even if you need to chain multiple asynchronous operations.

```csharp
// GOOD
public async Task GetDataAsync()
{
    var result = await MyWebService.FetchDataAsync();
    return new Data (result);
}
```
```csharp
// BAD
public Task GetDataAsync()
{
    return MyWebService.FetchDataAsync().ContinueWith(t => new Data(t.Result));
}
```
**Tip:** Even if you need to target .NET Framework 4.0 you can use the `async` and `await` keywords. Simply install the [Async Targeting Pack](http://www.microsoft.com/en-us/download/details.aspx?id=29576).
